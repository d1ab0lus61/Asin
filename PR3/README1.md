### Множення двох матриць з використанням **ForkJoinPool** та **ExecutorService**

Цей код демонструє два паралельні підходи до множення двох матриць, використовуючи:

- **ForkJoinPool** для розподілу завдань між потоками через рекурсивне програмування.
- **ExecutorService** з пулом потоків, щоб паралельно обчислювати кожен рядок матриці.


## Основні ідеї коду

1. **Генерація матриць**:
   - Випадкові матриці `matrixA` та `matrixB` створюються функцією `generateRandomMatrix`.
   
2. **Друк матриць**:
   - Друк здійснюється функцією `printMatrix`.

3. **Паралельне множення за допомогою ForkJoinPool**:
   - Кожен завдання обчислює відповідний рядок матриці `result`.
   - Завдання створюються за допомогою класу `RecursiveTask<Void>` і обробляються паралельно з використанням пулу потоків `ForkJoinPool`.

4. **Паралельне множення за допомогою ExecutorService**:
   - ExecutorService виконує завдання на кожному рядку матриці паралельно, використовуючи пул потоків.
   - Завдання додаються як `Callable` об'єкти до списку, після чого викликається метод `invokeAll`.

---

## Основні компоненти

1. **ForkJoinPool**:
   - Ефективний для задач, які можна розділити на дрібніші завдання (паралельні обчислення).

2. **ExecutorService**:
   - Пул потоків, що дозволяє виконувати багато завдань паралельно, не створюючи нові потоки вручну.

3. **Рекурсивний підхід**:
   - Використовується у ForkJoinPool для паралельного обчислення елементів матриць.

---

## Як працює код?

1. Користувач вводить розмір матриць.
2. Генеруються випадкові матриці.
3. Друкуються матриці.
4. Множення матриць паралельно обчислюється за двома підходами:
   - **ForkJoinPool** обчислює кожен рядок матриці окремо.
   - **ExecutorService** також обчислює кожен рядок матриці паралельно.
5. Виводиться обчислена матриця та час обчислень для обох підходів.

---

## Переваги використання паралельного обчислення

1. Зменшення часу обчислень при роботі з великими матрицями.
2. Оптимізація роботи на багатоядерних процесорах.
